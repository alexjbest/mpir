#!/bin/bash

# Usage: benchmark <function_name> <arguments_format> [file1, file2, ...]
# Where: function_name     is the full name of the function e.g. mpn_addadd_n
#        arguments_format  is a string specifying what the function requires as input,
#                          r specifies a return value is given, this can be needed to
#                          prevent GCC from optimising a function to nothing
#                          p represents a (pointer to an mpn)
#                          s stands for the size of the mpns
#                          currently supported: rps, ps, rpps, pps, ppps, pppps
#        file1, file2, ... are an arbitrary list of .asm or .as files containing
#                          implementations of the function, .asm should be
#                          att/gcc syntax, .as intel syntax

set -e

FUNC=$1
FORMAT=$2
FILES=${@:3}

if [ "$#" -lt 3 ]; then
	echo "error: not enough parameters"
	exit
fi

mkdir -p "benched-functions"
mkdir -p "tmp"

echo "benching: $FUNC"

# Get the appropriate line of the data file in which to put our new benchmark
BENCHLINE=$(cat -n data.yml | grep "$FUNC" -m1 -A10000 | grep "benchmarks" -m1 | awk '{print $1}' )
if [[ $BENCHLINE == "" ]]
then
	echo "warning: could not find location to add benchmark data for $FUNC, output will not be saved"
fi
#TODO if this fails, write the appropriate entry into data? with sensible defaults

CPU=$(cat /proc/cpuinfo | grep "model name" -m1 | cut -d: -f2)
GUESS=$(../config.guess)

m4 -Dfuncname=__g$FUNC -D$FORMAT bench.c > tmp/bench.c
gcc -c -I.. -o tmp/bench.o tmp/bench.c

for file in ${FILES[@]}
do
	if [[ ! -f $file ]] ; then
		echo "error: $file not found."
		continue
	fi
	echo "copying: $file"
	SUM=$(tr -d "[:blank:]" < $file | grep -v '^$\|^\s*\dnl\|^\s*\C\|^\s*\#\|^\s*\;' | md5sum | cut -c 1-32)
	#TODO could use different comment filters for different filetypes
	cp $file "benched-functions/$SUM-$(basename $file)"
	echo "hash: $SUM"

	echo "compiling: $file"
	if [[ $file == *.asm ]]
	then
		m4 $file > tmp/func.s
		gcc -c -I.. -o tmp/func.o tmp/func.s
	elif [[ $file == *.as ]]
	then
		cp $file tmp/func.s
		../yasm/yasm -f elf64 -I .. -o tmp/func.o tmp/func.s
	fi
	gcc tmp/bench.o tmp/func.o -L/home/best/mpir/.libs/ -Wl,-rpath,/home/best/mpir/.libs/ -lmpir -o tmp/bench

	if [[ $BENCHLINE != "" ]]
	then
		echo "timing: $file"
		OUTPUT=$( tmp/bench )
		#echo $OUTPUT
		DATE=$(date +"%F %T")
		sed -i "$BENCHLINE a\\ \ -\n\ \ \ \ date: $DATE\n\ \ \ \ hash: $SUM\n\ \ \ \ filepath: $file\n\ \ \ \ cpu: $CPU\n\ \ \ \ arch: $GUESS\n\ \ \ \ results: $OUTPUT" data.yml
	fi

done

echo -e "\n"

#rm -rf tmp
